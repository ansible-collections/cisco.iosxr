---
name: Auto Label

on:
  pull_request_target:
    types: [opened, edited, synchronize]
  issues:
    types: [opened, edited]

jobs:
  auto-label-pr:
    if: github.event_name == 'pull_request_target'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - name: Auto-label from PR template
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.payload.pull_request.number;
            const prBody = context.payload.pull_request.body || '';
            const labels = [];

            console.log(`Processing PR #${prNumber}`);
            console.log(`PR body length: ${prBody.length}`);
            console.log(`PR body preview: ${prBody.substring(0, 200)}...`);

            // Map Type of Change checkboxes to labels
            const typeLabels = {
              'Bug fix': 'bug',
              'New feature': 'enhancement',
              'New module': 'new-module',
              'Breaking change': 'breaking-change',
              'Documentation update': 'documentation',
              'Test update': 'tests',
              'Refactoring': 'refactor',
              'Collection release': 'release',
              'CI maintenance': 'ci',
              'Workflow maintenance': 'workflow',
              'Configuration change': 'config'
            };

            // Check for checked boxes in Type of Change section
            const typeSection = prBody.match(/## Type of Change[\s\S]*?(?=##|$)/);
            if (typeSection) {
              console.log(`Found Type of Change section: ${typeSection[0].substring(0, 300)}...`);
              for (const [templateText, label] of Object.entries(typeLabels)) {
                const regex = new RegExp(`- \\[x\\] ${templateText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}`, 'i');
                if (regex.test(typeSection[0])) {
                  console.log(`âœ“ Matched: "${templateText}" â†’ "${label}"`);
                  labels.push(label);
                }
              }
            } else {
              console.log('No Type of Change section found in PR body');
            }

            // Extract Component Name for component-specific labels
            const componentMatch = prBody.match(/## Component Name[\s\S]*?<!--[\s\S]*?Examples: ([^,]+)/);
            if (componentMatch) {
              const component = componentMatch[1].trim();
              if (component.includes('plugin')) {
                labels.push('plugin');
              } else if (component.includes('iosxr_')) {
                labels.push('module');
              }
            }

            // Add labels if any were found
            console.log(`Labels to add: ${labels.length > 0 ? labels.join(', ') : 'none'}`);
            if (labels.length > 0) {
              try {
                // Check if labels exist in the repository
                const existingLabels = await github.rest.issues.listLabelsForRepo({
                  owner: context.repo.owner,
                  repo: context.repo.repo
                });
                const existingLabelNames = existingLabels.data.map(l => l.name);
                const missingLabels = labels.filter(l => !existingLabelNames.includes(l));
                if (missingLabels.length > 0) {
                  console.log(`Warning: Labels not found in repository: ${missingLabels.join(', ')}`);
                }

                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  labels: labels
                });
                console.log(`âœ“ Successfully added labels: ${labels.join(', ')}`);
              } catch (error) {
                console.error(`âœ— Error adding labels: ${error.message}`);
                console.error(`Error details: ${JSON.stringify(error, null, 2)}`);
                // Don't fail the workflow if label addition fails
              }
            } else {
              console.log('No labels to add based on template');
            }
  auto-label-issue:
    if: github.event_name == 'issues'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
    steps:
      - name: Auto-label from Issue template
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issueBody = context.payload.issue.body || '';
            const labels = [];

            // GitHub issue forms store data in markdown format
            // Checkboxes appear as "- [x] Label" when checked
            // Extract components section
            const componentsSection = issueBody.match(/### Select the relevant components[\s\S]*?(?=###|$)/i);
            if (componentsSection) {
              const componentLabels = {
                'Module': 'module',
                'Action Plugin': 'plugin',
                'Connection Plugin \\(cliconf\\)': 'plugin',
                'Terminal Plugin': 'plugin',
                'Netconf Plugin': 'plugin',
                'Module Utils': 'module-utils',
                'Documentation': 'documentation',
                'Integration Tests': 'tests',
                'Unit Tests': 'tests',
                'Collection Release': 'release',
                'CI Maintenance': 'ci',
                'Workflow Maintenance': 'workflow'
              };

              // Check for checked components (format: - [x] Component Name)
              for (const [component, label] of Object.entries(componentLabels)) {
                const regex = new RegExp(`- \\[x\\] ${component}`, 'i');
                if (regex.test(componentsSection[0])) {
                  if (!labels.includes(label)) {
                    labels.push(label);
                  }
                }
              }
            }

            // Check if it's a bug report (has Bug Summary field)
            if (issueBody.includes('### Bug Summary') || issueBody.includes('ðŸž')) {
              if (!labels.includes('bug')) {
                labels.push('bug');
              }
            }

            // Check for feature request
            if (issueBody.includes('### Feature Summary') || issueBody.includes('âœ¨')) {
              if (!labels.includes('enhancement')) {
                labels.push('enhancement');
              }
            }

            // Add labels if any were found
            if (labels.length > 0) {
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.issue.number,
                  labels: labels
                });
                console.log(`Added labels: ${labels.join(', ')}`);
              } catch (error) {
                console.error(`Error adding labels: ${error.message}`);
                // Don't fail the workflow if label addition fails
              }
            } else {
              console.log('No labels to add based on template');
            }
