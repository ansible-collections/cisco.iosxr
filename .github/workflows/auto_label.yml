---
name: Auto Label

on:
  pull_request:
    types: [opened, edited, synchronize]
  issues:
    types: [opened, edited]

jobs:
  auto-label:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      issues: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Auto-label from PR template
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const prBody = context.payload.pull_request.body || '';
            const labels = [];
            
            // Map Type of Change checkboxes to labels
            const typeLabels = {
              'Bug fix': 'bug',
              'New feature': 'enhancement',
              'New module': 'new-module',
              'Breaking change': 'breaking-change',
              'Documentation update': 'documentation',
              'Test update': 'tests',
              'Refactoring': 'refactor',
              'Collection release': 'release',
              'CI maintenance': 'ci',
              'Workflow maintenance': 'workflow',
              'Configuration change': 'config'
            };
            
            // Check for checked boxes in Type of Change section
            const typeSection = prBody.match(/## Type of Change[\s\S]*?(?=##|$)/);
            if (typeSection) {
              for (const [templateText, label] of Object.entries(typeLabels)) {
                const regex = new RegExp(`- \\[x\\] ${templateText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}`, 'i');
                if (regex.test(typeSection[0])) {
                  labels.push(label);
                }
              }
            }
            
            // Extract Component Name for component-specific labels
            const componentMatch = prBody.match(/## Component Name[\\s\\S]*?<!--[\\s\\S]*?Examples: ([^,]+)/);
            if (componentMatch) {
              const component = componentMatch[1].trim();
              if (component.includes('plugin')) {
                labels.push('plugin');
              } else if (component.startsWith('iosxr_')) {
                labels.push('module');
              }
            }
            
            // Add labels if any were found
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                labels: labels
              });
              console.log(`Added labels: ${labels.join(', ')}`);
            }

      - name: Auto-label from Issue template
        if: github.event_name == 'issues'
        uses: actions/github-script@v7
        with:
          script: |
            const issueBody = context.payload.issue.body || '';
            const labels = [];
            
            // GitHub issue forms store data in markdown format
            // Checkboxes appear as "- [x] Label" when checked
            // Extract components section
            const componentsSection = issueBody.match(/### Select the relevant components[\s\S]*?(?=###|$)/i);
            if (componentsSection) {
              const componentLabels = {
                'Module': 'module',
                'Action Plugin': 'plugin',
                'Connection Plugin \\(cliconf\\)': 'plugin',
                'Terminal Plugin': 'plugin',
                'Netconf Plugin': 'plugin',
                'Module Utils': 'module-utils',
                'Documentation': 'documentation',
                'Integration Tests': 'tests',
                'Unit Tests': 'tests',
                'Collection Release': 'release',
                'CI Maintenance': 'ci',
                'Workflow Maintenance': 'workflow'
              };
              
              // Check for checked components (format: - [x] Component Name)
              for (const [component, label] of Object.entries(componentLabels)) {
                const regex = new RegExp(`- \\[x\\] ${component}`, 'i');
                if (regex.test(componentsSection[0])) {
                  if (!labels.includes(label)) {
                    labels.push(label);
                  }
                }
              }
            }
            
            // Check if it's a bug report (has Bug Summary field)
            if (issueBody.includes('### Bug Summary') || issueBody.includes('ðŸž')) {
              if (!labels.includes('bug')) {
                labels.push('bug');
              }
            }
            
            // Check for feature request
            if (issueBody.includes('### Feature Summary') || issueBody.includes('âœ¨')) {
              if (!labels.includes('enhancement')) {
                labels.push('enhancement');
              }
            }
            
            // Add labels if any were found
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                labels: labels
              });
              console.log(`Added labels: ${labels.join(', ')}`);
            } else {
              console.log('No labels to add based on template');
            }

